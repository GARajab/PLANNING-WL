-- Wayleave Management System - Supabase Database Setup Script
-- This script will configure the necessary tables, types, functions, and security policies.

-- 1. Create Custom Types
-- These ENUM types ensure data consistency for user roles and record statuses.
-- Drop types if they exist to make the script re-runnable.
DROP TYPE IF EXISTS public.user_role CASCADE;
DROP TYPE IF EXISTS public.wayleave_status CASCADE;

CREATE TYPE public.user_role AS ENUM ('Admin', 'EDD Planning', 'Consultation Team');
CREATE TYPE public.wayleave_status AS ENUM ('Pending with EDD', 'Sent to M.O.W', 'Received from M.O.W', 'Sent to Area Engineer');

-- 2. Create the 'profiles' table
-- This table stores user-specific information and is linked to the 'auth.users' table.
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  cpr text UNIQUE,
  name text,
  role public.user_role
);
-- Add comments for clarity
COMMENT ON TABLE public.profiles IS 'Stores public user information.';
COMMENT ON COLUMN public.profiles.id IS 'Links to auth.users.id';

-- 3. Create the 'wayleave_records' table
-- This is the main table for storing wayleave task information.
CREATE TABLE public.wayleave_records (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  wayleave_number text NOT NULL,
  status public.wayleave_status NOT NULL,
  to_edd_date timestamp with time zone,
  to_mow_date timestamp with time zone,
  from_mow_date timestamp with time zone,
  to_area_engineer_date timestamp with time zone,
  usp_number text,
  rcc_number text,
  msp_number text,
  attachments text[],
  remarks text,
  last_updated_by text
);
-- Add comments for clarity
COMMENT ON TABLE public.wayleave_records IS 'Stores all wayleave records and their statuses.';

-- 4. Create RPC Function to handle new user profiles
-- The AuthService calls this function after a successful sign-up to create a profile entry.
DROP FUNCTION IF EXISTS public.create_user_profile();
CREATE OR REPLACE FUNCTION public.create_user_profile()
RETURNS public.profiles AS $$
DECLARE
  new_user_id uuid := auth.uid();
  new_user_email text := (SELECT email FROM auth.users WHERE id = new_user_id);
  new_user_cpr text := split_part(new_user_email, '@', 1);
  new_profile public.profiles;
BEGIN
  INSERT INTO public.profiles (id, cpr, name, role)
  VALUES (new_user_id, new_user_cpr, 'User ' || new_user_cpr, NULL)
  RETURNING * INTO new_profile;
  RETURN new_profile;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5. Helper function to get the current user's role
-- This simplifies writing Row-Level Security (RLS) policies.
DROP FUNCTION IF EXISTS public.get_user_role();
CREATE OR REPLACE FUNCTION public.get_user_role()
RETURNS public.user_role AS $$
BEGIN
  RETURN (SELECT role FROM public.profiles WHERE id = auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5.5. Create RPC Function for Admins to get all user profiles
-- This allows admins to bypass the stricter SELECT RLS policy on the profiles table.
DROP FUNCTION IF EXISTS public.get_all_users();
CREATE OR REPLACE FUNCTION public.get_all_users()
RETURNS SETOF public.profiles
AS $$
BEGIN
    -- Only allow admins to execute this function
    IF get_user_role() <> 'Admin' THEN
        RAISE EXCEPTION 'Forbidden: You must be an admin to view all users.';
    END IF;
    
    RETURN QUERY SELECT * FROM public.profiles ORDER BY name ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 6. Set up Row-Level Security (RLS)
-- These policies are crucial for securing your data.
-- Enable RLS on the tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.wayleave_records ENABLE ROW LEVEL SECURITY;

-- RLS Policies for 'profiles' table
-- First, remove any existing policies to avoid conflicts
DROP POLICY IF EXISTS "Admins can view all profiles." ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Authenticated users can view profiles." ON public.profiles;
DROP POLICY IF EXISTS "Admins can update any profile." ON public.profiles;

-- SIMPLIFIED SELECT POLICY: Users can only select their own profile directly.
-- Admins must use the 'get_all_users' RPC to view all profiles, which avoids RLS recursion.
CREATE POLICY "Users can view their own profile." ON public.profiles
  FOR SELECT TO authenticated USING (auth.uid() = id);

CREATE POLICY "Admins can update any profile." ON public.profiles
  FOR UPDATE TO authenticated USING (get_user_role() = 'Admin');

-- RLS Policies for 'wayleave_records' table
-- First, remove any existing policies to avoid conflicts
DROP POLICY IF EXISTS "Authenticated users can view all records." ON public.wayleave_records;
DROP POLICY IF EXISTS "Admins and EDD Planners can create records." ON public.wayleave_records;
DROP POLICY IF EXISTS "Admins and Consultants can update records." ON public.wayleave_records;
DROP POLICY IF EXISTS "Admins can delete records." ON public.wayleave_records;

CREATE POLICY "Authenticated users can view all records." ON public.wayleave_records
  FOR SELECT TO authenticated USING (true);

CREATE POLICY "Admins and EDD Planners can create records." ON public.wayleave_records
  FOR INSERT TO authenticated WITH CHECK (get_user_role() IN ('Admin', 'EDD Planning'));

CREATE POLICY "Admins and Consultants can update records." ON public.wayleave_records
  FOR UPDATE TO authenticated USING (get_user_role() IN ('Admin', 'Consultation Team'));

CREATE POLICY "Admins can delete records." ON public.wayleave_records
  FOR DELETE TO authenticated USING (get_user_role() = 'Admin');

-- 7. Configure Supabase Storage
-- Create a public bucket for file attachments. The app uses public URLs.
INSERT INTO storage.buckets (id, name, public)
VALUES ('attachments', 'attachments', true)
ON CONFLICT (id) DO NOTHING;

-- Storage Policies
-- First, remove any existing policies to avoid conflicts
DROP POLICY IF EXISTS "Authenticated users can view attachments" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can upload attachments" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can delete attachments" ON storage.objects;

CREATE POLICY "Authenticated users can view attachments" ON storage.objects
  FOR SELECT TO authenticated USING ( bucket_id = 'attachments' );

CREATE POLICY "Authenticated users can upload attachments" ON storage.objects
  FOR INSERT TO authenticated WITH CHECK ( bucket_id = 'attachments' );

CREATE POLICY "Authenticated users can delete attachments" ON storage.objects
  FOR DELETE TO authenticated USING ( bucket_id = 'attachments' );

-- --- END OF SCRIPT ---
-- You can now run the application.
-- Remember to create an initial 'Admin' user by manually setting the 'role'
-- in the 'profiles' table after the user has signed up.